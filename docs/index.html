<html><head>
<script src="IParse.js"></script>
<script src="d3.v3.min.js"></script>
<script src="d3Tree.js"></script>
<link rel="stylesheet" type="text/css" href="tree-viewer.css">
<script>
<!--

var iparse = new IParse

var exprGrammar = iparse.parseGrammar(
	"root : expr \"=\"."+
	"expr : expr \"+\" term [add] | expr \"-\" term [sub] | term."+
	"term :	term \"*\" factor [times]| term \"/\" factor [div] | factor."+
	"factor : int | \"(\" expr \")\" | \"-\" factor [min].")

function eval_ast(input_tree)
{
	var vars = []
	var gresult = ""
	var error_msg = undefined
	var eval = function(ast)
	{
		if (ast == undefined) return undefined
		if (ast.type == "int" || ast.type == "double" || ast.type == "string" || ast.type == "char") return ast.value
		if (ast.type == "ident")
		{
			for (var i = 0; i < vars.length; i++)
				if (vars[i].name == ast.value)
					return vars[i].value
			return undefined
		}
		if (ast.children == undefined) return undefined
		if (ast.type == "list")
		{
			var s = 0
			for (var i = 0; i < ast.children.length; i++)
				s = eval(ast.children[i])
			return s
		}
		if (ast.type == "tree")
		{
			if (ast.name == "add") return ast.children.length == 2 ? eval(ast.children[0]) + eval(ast.children[1]) : undefined
			if (ast.name == "sub") return ast.children.length == 2 ? eval(ast.children[0]) - eval(ast.children[1]) : undefined
			if (ast.name == "times") return ast.children.length == 2 ? eval(ast.children[0]) * eval(ast.children[1]) : undefined
			if (ast.name == "div") return ast.children.length == 2 ? eval(ast.children[0]) / eval(ast.children[1]) : undefined
			if (ast.name == "mod") return ast.children.length == 2 ? eval(ast.children[0]) % eval(ast.children[1]) : undefined
			if (ast.name == "sum")
			{
				var childs = (ast.children.length == 1 && ast.children[0] != undefined && ast.children[0].type == "list") ? ast.children[0].children : ast.children
				var s = 0
				for (var i = 0; i < childs.length; i++)
					s += eval(childs[i])
				return s
			}
			if (ast.name == "multiply")
			{
				var childs = (ast.children.length == 1 && ast.children[0] != undefined && ast.children[0].type == "list") ? ast.children[0].children : ast.children
				var s = 1
				for (var i = 0; i < childs.length; i++)
					s *= eval(childs[i])
				return s
			}
			if (ast.name == "min") return ast.children.length == 1 ? -eval(ast.children[0]) : undefined
			if (ast.name == "le") return ast.children.length == 2 ? eval(ast.children[0]) < eval(ast.children[1]) : undefined
			if (ast.name == "lt") return ast.children.length == 2 ? eval(ast.children[0]) <= eval(ast.children[1]) : undefined
			if (ast.name == "ge") return ast.children.length == 2 ? eval(ast.children[0]) > eval(ast.children[1]) : undefined
			if (ast.name == "gt") return ast.children.length == 2 ? eval(ast.children[0]) >= eval(ast.children[1]) : undefined
			if (ast.name == "eq") return ast.children.length == 2 ? eval(ast.children[0]) == eval(ast.children[1]) : undefined
			if (ast.name == "ne") return ast.children.length == 2 ? eval(ast.children[0]) != eval(ast.children[1]) : undefined
			if (ast.name == "and") return ast.children.length == 2 ? eval(ast.children[0]) && eval(ast.children[1]) : undefined
			if (ast.name == "or") return ast.children.length == 2 ? eval(ast.children[0]) || eval(ast.children[1]) : undefined
			if (ast.name == "not") return ast.children.length == 1 ? !eval(ast.children[0]) : undefined
			if (ast.name == "ass")
			{
				if (ast.children.length != 2) return undefined
				if (ast.children[0].type != "ident") return undefined
				var n = ast.children[0].value
				var v = eval(ast.children[1])
				for (var i = 0; i < vars.length; i++)
					if (vars[i].name == n)
					{
						vars[i].value = v
						return v
					}
				vars.push({ name:n, value:v })
				return v
			}
			if (ast.name == "assto")
			{
				if (ast.children.length != 2) return undefined
				if (ast.children[1].type != "ident") return undefined
				var n = ast.children[1].value
				var v = eval(ast.children[0])
				for (var i = 0; i < vars.length; i++)
					if (vars[i].name == n)
					{
						vars[i].value = v
						return v
					}
				vars.push({ name:n, value:v })
				return v
			}
			if (ast.name == "print")
			{
				if (ast.children.length != 1) return undefined
				var v = eval(ast.children[0])
				gresult += v + "\n"
				return v
			}
			if (ast.name == "prompt")
			{
				if (ast.children.length != 1) return undefined
				var msg = eval(ast.children[0])
				var v = prompt(msg)
				if (/^[-+]?(\d+|Infinity)$/.test(v)) v = Number(v)
				return v
			}
			if (ast.name == "ifthenelse")
			{
				if (ast.children.length != 3) return undefined
				return eval(ast.children[0]) == true ? eval(ast.children[1]) : eval(ast.children[2])
			}
			if (ast.name == "whenotherwise")
			{
				if (ast.children.length != 3) return undefined
				return eval(ast.children[1]) == true ? eval(ast.children[0]) : eval(ast.children[2])
			}
			if (ast.name == "while")
			{
				if (ast.children.length != 2) return undefined
				var s = undefined
				while (eval(ast.children[0]) == true)
					s = eval(ast.children[1])
				return s
			}
			if (ast.name == "defaultsto")
			{
				if (ast.children.length != 2) return undefined
				var v = eval(ast.children[0])
				return v != undefined ? v : eval(ast.children[1])
			}
		}
		return undefined
	}
	if (input_tree == false)
		return "  ?"
	var result = eval(input_tree)
	if (error_msg != undefined)
		return "  ?"
	else
		return result
}

function parseSimpleExpr()
{
	var ast = iparse.parse(document.SimpleExpr.input.value, exprGrammar)
	document.SimpleExpr.output.value = eval_ast(ast)
}

function showHide(button)
{
	var x = document.getElementById(button.id+"text")
	if (button.textContent == "show")
	{
		x.style.display = "block"
		button.textContent = "hide"
	}
	else
	{
		x.style.display = "none"
		button.textContent = "show"
	}
}

var expr2Grammar = iparse.parseGrammar(
	"root : expr."+
	"expr : expr \"+\" term [add] | expr \"-\" term [sub] | term."+
	"term :	term \"*\" factor [times]| term \"/\" factor [div] | factor."+
	"factor : int | \"(\" expr \")\" | \"-\" factor [min].")

function parseSyntaxTree()
{
	var ast = iparse.parse(document.SyntaxTree.input.value, expr2Grammar)
	if (ast == false)
		d3Tree({ name:"???" }, "tree-container")
	else
		d3Tree( ast.transf(), "tree-container")
}

function parseExample(formname, evaluate)
{
	var g = iparse.parseGrammar(document[formname].grammar.value)
	if (g == false)
	{
		document[formname].output.value = "Grammar "+iparse.reportExpecting()
		d3Tree({ name:"???" }, formname+"tree")
	}
	else
	{
		var ast = iparse.parse(document[formname].input.value, g)
		if (ast == false)
		{
			document[formname].output.value = "Input "+iparse.reportExpecting()
			d3Tree({ name:"???" }, formname+"tree")
		}
		else
		{
			document[formname].output.value = ast.print() + (evaluate != undefined ? " = " + eval_ast(ast) : "")
			d3Tree( ast.transf(), formname+"tree")
		}
	}
}

function evalExample(formname) { parseExample(formname, true) }

//--></script>
<title>MCH2022: A practical approach to parsing</title>
</head><body>

<h1>Workshop: A practical approach to parsing</h1>

This is a page for a workshop at <a href="https://mch2022.org/">MCH2022</A>
about parsing. It serves as both an interactive page to be used during the
workshop and as an introduction to parsing. Use the show buttons to reveal
the explainatory texts.

<h2>What is 3 + 4?</h2>

<style>
div.hidden { display: none; }
</style>

<form name="SimpleExpr">
<textarea name="input" rows="2" cols="80" onkeyup="parseSimpleExpr()">3 + 4 </textarea>
<textarea name="output" rows="1" cols="20"></textarea>
</form>
(type '=' in the input field above to see the answer.)
<p>
<div id="button1text" class="hidden">
Most of use when we read the text '3&nbsp;+&nbsp;4' will immediately think
about seven as the answer. To arrive at this answer, we have read the symbol
'3' and realized that it stands for the number three. Likewise we read four
for the symbol '4'. We also have been taught that the symbol '+' stands for
adding and in our head we add the number three and four to arrive at seven.
<p>
There are some more implicite rules that we employ. We do read the text
'3&nbsp;3' as twice the nunber three, were we read '33' as thirty three. So a
space does matter when placed between digits, whereas we read '3+4' the same as
'3&nbsp;+&nbsp;4'.
<p>
</div> <button id="button1" onclick="showHide(this)">show</button>

<h2>What is 3 + 2 * 2 - 1? 9 or 6?</h2>

<div id="button2text" class="hidden">
If you enter 3 + 2 * 2 - 1 in a pocket calculator the answer will probably be
9, because adding three and two gives five. If you next multiply this with two
you get ten. If you subtract one from ten you arrive at nine.
<p>
However, if you take the rule that multiplication (and division) goes before
adding and substracting, you will start with multiplying two with two and if
you substract one from three added with four, you arrive at six.
<p>
In the first case you assume that all operators have the same priority in the
second you assume that some operations have a higher priority than others.
<p>
You can force one of the two interpretations by using round brackets:
<ul>
<li>(3 + 2) * 2 - 1 will return nine
<li>3 + (2 * 2) - 1 will return six
</ul>
Try enter these expression in the input field of the previous paragraph to see
which operator priorities are implemented in this expression evaluator.
<p>
</div> <button id="button2" onclick="showHide(this)">show</button>

<h2>What is 12 / 2/2? 12 or 3?</h2>

<div id="button3text" class="hidden">
2/2 is one and twelve divided by one is twelve. But 12 divided by 2 is six and
six divided again by 2 is three. Assuming that spaces have no semantic meaning,
than the question here is, whether the divide operator is left or right
associative. Depending on this, the brackets are thought to be placed as:
<ul>
<li>Left associative: (12 / 2) / 2
<li>right associative: 12 (2 / 2)
</ul>
Note that for 3&nbsp;*&nbsp;2&nbsp;*&nbsp;5 it does not matter whether we place the brackets
like (3&nbsp;*&nbsp;2)&nbsp;*&nbsp;5 or 3&nbsp;*&nbsp;(2&nbsp;*&nbsp;5).
<p>
</div> <button id="button3" onclick="showHide(this)">show</button>

<h2>Abstract syntax tree</h2>

<div id="button4text" class="hidden">
An alternative way to represent expressions without using brackets is to use
a tree. (By custom these trees are drawn up-side down.) Below such a tree is
shown for the given expression. Experiment with changing the expression. If
the expression is not correct, three question marks are displayed.
<p>
Such a tree is also called an abstract syntax tree, because it abstracts from
the concrete syntax using characters. From the syntax tree, one cannot see if
brackets were used in the input or not in case they do not make any difference
in how the expression should be calculated. To calculate the value of the
syntax tree below, find a node that only has numbers below them and replace
that node by the result of applying the operation to the numbers. Repeat this
until there is no such node any more.
<p>
</div> <button id="button4" onclick="showHide(this)">show</button>
<p>
<center>
<form name="SyntaxTree">
<textarea name="input" rows="2" cols="80" onkeyup="parseSyntaxTree()">3 + 4</textarea>
</form>

<div id="tree-container" style="width: 80%; height: 500px"></div>
</center>

<script><!--
parseSyntaxTree()
//--></script>

<h2>Railroad diagrams or production rules</h2>

<div id="button5text" class="hidden">
There are various ways to specify a grammar for how an input text needs to be
transformed into an abstract syntax tree. Some of these are:
<ul>
<li>Textual description
<li><a href="https://en.wikipedia.org/wiki/Syntax_diagram"
	>Railroad diagrams</a>
<li><a href="https://en.wikipedia.org/wiki/Production_(computer_science)"
	>Production rules</a>
</ul>
The idea of railroad diagrams is that you represent the grammar by a number of
boxes and lines with switches that connect the boxes. The boxes can contain
characters or the names of other railroad diagrams. An example of railroad
diagrams for arithmetic expressions can be found in
<a href="https://www.sigmdel.ca/michel/program/delphi/parser/parser1_en.html"
>Parsing a Simplified Grammar</A>. (This page also contains some production
rules, but these production rules are incorrect.)
Railroad diagrams are nice to explain a grammar, but for speficying them, you
also need some tool that can interpret them.
<p>
In the rest of this workshop we are going to work with grammars that are
specified with production rules.
<p>
</div> <button id="button5" onclick="showHide(this)">show</button>

<h2>Terminals</h2>

<div id="button6text" class="hidden">
Terminals in a formal langual are the like lexical elements of a natural
language. In a natural language we have word, numbers, and punctuation marks.
In programming language, we have integers, floating point numbers, identifiers,
strings (a sequence of characters between quotation marks), keywords,
operators and such.
<p>
Below a production rule is given for parsing three terminals. On the left-hand
side of the colon, the word '<tt>root</tt>' is given. This is the starting
point of the grammar. On the right-hand side of the colon, the names of three
terminals is given. The word '<tt>int</tt>' is denoted to represent an integer
number, the word '<tt>ident</tt>' is denoted to represent an identifier, and
the word '<tt>string</tt>' is denoted to represent an string between double
quotes. A period is used to denote the end of the production rule.
<p>
</div> <button id="button6" onclick="showHide(this)">show</button>
<p>
<form name="Terminals">
Grammar:<br>
<textarea name="grammar" rows="2" cols="80" onkeyup="parseExample('Terminals')">root : int ident string .</textarea>
<p>
Input:<br>
<textarea name="input" rows="2" cols="80" onkeyup="parseExample('Terminals')">3 me "abc"</textarea>
<p>
Output:<br>
<textarea name="output" rows="2" cols="80"></textarea>
</form>

<script><!--
parseExample("Terminals")
//--></script>

<h2>Literals and keywords</h2>

<div id="button7text" class="hidden">
Two other types of terminals in programming languages are literals and keyword.
In a grammar we can define these by placing some text in between double
quotes. If the text starts with an alphabetic character, it is taken as a
keyword. (Sometimes keywords are also called reserved words.) Keywords usually
overlap with identifiers. It is thus logical to exclude keywords from the
identifiers. This can be tested in the input by replacing the <tt>a</tt> by
<tt>if</tt>. For literals the rule is that the characters should appear
directly after each other, without space between them. This can be tested in
the input by inserting a space between the two colons.
<p>
</div> <button id="button7" onclick="showHide(this)">show</button>
<p>
<form name="Literals">
Grammar:<br>
<textarea name="grammar" rows="2" cols="80" onkeyup="parseExample('Literals')">root : "if" ident "::" .</textarea>
<p>
Input:<br>
<textarea name="input" rows="2" cols="80" onkeyup="parseExample('Literals')">if a ::</textarea>
<p>
Output:<br>
<textarea name="output" rows="2" cols="80"></textarea>
</form>

<script><!--
parseExample("Literals")
//--></script>

<h2>Non-terminals</h2>

<div id="button8text" class="hidden">
Below a grammar consisting of three rules is shown to parse a very simple
expression. In this grammar the non-terminal <tt>expr</tt> is a non-terminal.
(Actually, the text <tt>root</tt> is also a non-terminal. A special one that
denotes the start of the grammar.) The non-terminal <tt>expr</tt> is used in
the first rule to represent the experssion that is followed by an equal sign.
The last two rules specify what the expression may consist of Either
integer followed by a plus sign and another integer or a single integer.
<p>
In our grammar definition, the order of the rules does matter. The first
grammar rule of a non-terminal that parses a text takes precedence over
following rules. If one swaps the last two rules in the example below, the
input will no longer be parsed.
<p>
</div> <button id="button8" onclick="showHide(this)">show</button>
<p>
<form name="Grammar1">
Grammar:<br>
<textarea name="grammar" rows="4" cols="80" onkeyup="parseExample('Grammar1')">root : expr "=" .
expr : int "+" int .
expr : int .</textarea>
<p>
Input:<br>
<textarea name="input" rows="2" cols="80" onkeyup="parseExample('Grammar1')">3 + 4 =</textarea>
<p>
Output:<br>
<textarea name="output" rows="2" cols="80"></textarea>
</form>

<script><!--
parseExample("Grammar1")
//--></script>

<h2>Add and substract</h2>

<div id="button9text" class="hidden">
In the grammar below a grammar rule with a minus sign is included for
substraction. To make a difference between these two rules in the abstract
syntax tree, we have added the words <tt>add</tt> and <tt>sub</tt> between
square brackets at the end of the rule. Replace the plus sign in the input
with a minus sign to see the effect in the output.
<p>
</div> <button id="button9" onclick="showHide(this)">show</button>
<p>
<form name="Grammar2">
Grammar:<br>
<textarea name="grammar" rows="5" cols="80" onkeyup="evalExample('Grammar2')">root : expr "=" .
expr : int "+" int [add] .
expr : int "-" int [sub] .
expr : int .</textarea>
<p>
Input:<br>
<textarea name="input" rows="2" cols="80" onkeyup="evalExample('Grammar2')">3 + 4 =</textarea>
<p>
Output:<br>
<textarea name="output" rows="2" cols="80"></textarea>
</form>

<script><!--
evalExample("Grammar2")
//--></script>

<h2>Left and right recursion</h2>

<div id="button10text" class="hidden">
The above grammar does not allow us to parse additions of more than two
numbers. In the grammar below, the grammar rules have been slightly modified.
Note that in the second and third rule the first terminal <tt>int</tt> has been
replaced by the non-terminal <tt>expr</tt>. Rules where the non-terminal
appears as the first element are called <a href="https://en.wikipedia.org/wiki/Left_recursion"
>left recursuve</a>. If we would have replaced the second terminal <tt>int</tt>
in both grammar rules with <tt>expr</tt> instead, we would have gotten right
recusion. Try this yourself by modifying the grammar.
<p>
</div> <button id="button10" onclick="showHide(this)">show</button>
<p>
<form name="Grammar3">
Grammar:<br>
<textarea name="grammar" rows="5" cols="80" onkeyup="evalExample('Grammar3')">root : expr "=" .
expr : expr "+" int [add] .
expr : expr "-" int [sub] .
expr : int .</textarea>
<p>
Input:<br>
<textarea name="input" rows="2" cols="80" onkeyup="evalExample('Grammar3')">3 + 4 - 5 =</textarea>
<p>
Output:<br>
<textarea name="output" rows="2" cols="80"></textarea>
</form>
<p>
<div id="Grammar3tree" style="width: 600px; height: 400px"></div>

<script><!--
evalExample("Grammar3")
//--></script>

<h2>Bar symbol</h2>

<div id="button11text" class="hidden">
As a shorthand it is possible to use the bar symbol ('|') to combine the
various rules for one non-terminal into a single rule. This is shown in the
grammar below, which is the grammar that was used at the start for arithmetic
expressions.
<p>
</div> <button id="button11" onclick="showHide(this)">show</button>
<p>
<form name="Grammar4">
Grammar:<br>
<textarea name="grammar" rows="5" cols="80" onkeyup="evalExample('Grammar4')">root : expr "=" .
expr : expr "+" term [add] | expr "-" term [sub] | term .
term : term "*" factor [times] | term "/" factor [div] | factor .
factor : int | "(" expr ")" | "-" factor [min] .
</textarea>
<p>
Input:<br>
<textarea name="input" rows="2" cols="80" onkeyup="evalExample('Grammar4')">3 + 4 * 5 =</textarea>
<p>
Output:<br>
<textarea name="output" rows="2" cols="80"></textarea>
</form>
<div id="Grammar4tree" style="width: 600px; height: 400px"></div>

<script><!--
evalExample("Grammar4")
//--></script>







<pre>






</pre>
<!--
<div id="button2text" class="hidden">
</div> <button id="button2" onclick="showHide(this)">show</button>
-->
<hr>

<h2>Acknowledgements</h2>

The code for showing the syntax tree is based on <A HREF="http://christos-c.com/treeviewer/"
>Syntactic Tree Viewer</A> by <A HREF="http://christos-c.com/">Christos
Christodoulopoulos</A>, which makes use of <A HREF="https://d3js.org/"
>d3.js</A> and itself is inspired by <A HREF="https://gist.github.com/robschmuecker/7880033"
>D3.js Drag and Drop Zoomable Tree</A> by <A HREF="https://gist.github.com/robschmuecker"
>Rob Schmuecker</A>.

<h2>Work in progress</h2>

This is still work in progress. It will be an improved version of the workshop
<a href="https://fransfaase.github.io/ParserWorkshop/Online_inter_parser.html"
>A modern approach to parsing</A> that I gave on March 20, 2021.


<p>
Author: <a href="https://www.iwriteiam.nl/Frans.html">Frans</a><br>
<a href="https://www.iwriteiam.nl/">Personal website</a><br>
<a href="https://www.iwriteiam.nl/index.html#email">email address</a>
</body></html>
