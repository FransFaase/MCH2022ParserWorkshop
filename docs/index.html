<html><head>
<script src="IParse.js"></script>
<script src="d3.v3.min.js"></script>
<script src="d3Tree.js"></script>
<link rel="stylesheet" type="text/css" href="tree-viewer.css">
<script>
<!--

var iparse = new IParse

var exprGrammar = iparse.parseGrammar(
	"root : expr \"=\"."+
	"expr : expr \"+\" term [add] | expr \"-\" term [sub] | term."+
	"term :	term \"*\" factor [times]| term \"/\" factor [div] | factor."+
	"factor : int | \"(\" expr \")\" | \"-\" factor [min].")

function eval_ast(input_tree)
{
	var vars = []
	var gresult = ""
	var error_msg = undefined
	var eval = function(ast)
	{
		if (ast == undefined) return undefined
		if (ast.type == "int" || ast.type == "double" || ast.type == "string" || ast.type == "char") return ast.value
		if (ast.type == "ident")
		{
			for (var i = 0; i < vars.length; i++)
				if (vars[i].name == ast.value)
					return vars[i].value
			return undefined
		}
		if (ast.children == undefined) return undefined
		if (ast.type == "list")
		{
			var s = 0
			for (var i = 0; i < ast.children.length; i++)
				s = eval(ast.children[i])
			return s
		}
		if (ast.type == "tree")
		{
			if (ast.name == "add") return ast.children.length == 2 ? eval(ast.children[0]) + eval(ast.children[1]) : undefined
			if (ast.name == "sub") return ast.children.length == 2 ? eval(ast.children[0]) - eval(ast.children[1]) : undefined
			if (ast.name == "times") return ast.children.length == 2 ? eval(ast.children[0]) * eval(ast.children[1]) : undefined
			if (ast.name == "div") return ast.children.length == 2 ? eval(ast.children[0]) / eval(ast.children[1]) : undefined
			if (ast.name == "mod") return ast.children.length == 2 ? eval(ast.children[0]) % eval(ast.children[1]) : undefined
			if (ast.name == "sum")
			{
				var childs = (ast.children.length == 1 && ast.children[0] != undefined && ast.children[0].type == "list") ? ast.children[0].children : ast.children
				var s = 0
				for (var i = 0; i < childs.length; i++)
					s += eval(childs[i])
				return s
			}
			if (ast.name == "multiply")
			{
				var childs = (ast.children.length == 1 && ast.children[0] != undefined && ast.children[0].type == "list") ? ast.children[0].children : ast.children
				var s = 1
				for (var i = 0; i < childs.length; i++)
					s *= eval(childs[i])
				return s
			}
			if (ast.name == "min") return ast.children.length == 1 ? -eval(ast.children[0]) : undefined
			if (ast.name == "le") return ast.children.length == 2 ? eval(ast.children[0]) < eval(ast.children[1]) : undefined
			if (ast.name == "lt") return ast.children.length == 2 ? eval(ast.children[0]) <= eval(ast.children[1]) : undefined
			if (ast.name == "ge") return ast.children.length == 2 ? eval(ast.children[0]) > eval(ast.children[1]) : undefined
			if (ast.name == "gt") return ast.children.length == 2 ? eval(ast.children[0]) >= eval(ast.children[1]) : undefined
			if (ast.name == "eq") return ast.children.length == 2 ? eval(ast.children[0]) == eval(ast.children[1]) : undefined
			if (ast.name == "ne") return ast.children.length == 2 ? eval(ast.children[0]) != eval(ast.children[1]) : undefined
			if (ast.name == "and") return ast.children.length == 2 ? eval(ast.children[0]) && eval(ast.children[1]) : undefined
			if (ast.name == "or") return ast.children.length == 2 ? eval(ast.children[0]) || eval(ast.children[1]) : undefined
			if (ast.name == "not") return ast.children.length == 1 ? !eval(ast.children[0]) : undefined
			if (ast.name == "ass")
			{
				if (ast.children.length != 2) return undefined
				if (ast.children[0].type != "ident") return undefined
				var n = ast.children[0].value
				var v = eval(ast.children[1])
				for (var i = 0; i < vars.length; i++)
					if (vars[i].name == n)
					{
						vars[i].value = v
						return v
					}
				vars.push({ name:n, value:v })
				return v
			}
			if (ast.name == "assto")
			{
				if (ast.children.length != 2) return undefined
				if (ast.children[1].type != "ident") return undefined
				var n = ast.children[1].value
				var v = eval(ast.children[0])
				for (var i = 0; i < vars.length; i++)
					if (vars[i].name == n)
					{
						vars[i].value = v
						return v
					}
				vars.push({ name:n, value:v })
				return v
			}
			if (ast.name == "print")
			{
				if (ast.children.length != 1) return undefined
				var v = eval(ast.children[0])
				gresult += v + "\n"
				return v
			}
			if (ast.name == "prompt")
			{
				if (ast.children.length != 1) return undefined
				var msg = eval(ast.children[0])
				var v = prompt(msg)
				if (/^[-+]?(\d+|Infinity)$/.test(v)) v = Number(v)
				return v
			}
			if (ast.name == "ifthenelse")
			{
				if (ast.children.length != 3) return undefined
				return eval(ast.children[0]) == true ? eval(ast.children[1]) : eval(ast.children[2])
			}
			if (ast.name == "whenotherwise")
			{
				if (ast.children.length != 3) return undefined
				return eval(ast.children[1]) == true ? eval(ast.children[0]) : eval(ast.children[2])
			}
			if (ast.name == "while")
			{
				if (ast.children.length != 2) return undefined
				var s = undefined
				while (eval(ast.children[0]) == true)
					s = eval(ast.children[1])
				return s
			}
			if (ast.name == "defaultsto")
			{
				if (ast.children.length != 2) return undefined
				var v = eval(ast.children[0])
				return v != undefined ? v : eval(ast.children[1])
			}
		}
		return undefined
	}
	if (input_tree == false)
		return "  ?"
	var result = eval(input_tree)
	if (error_msg != undefined)
		return "  ?"
	else
		return result
}

function parseSimpleExpr()
{
	var ast = iparse.parse(document.SimpleExpr.input.value, exprGrammar)
	document.SimpleExpr.output.value = eval_ast(ast)
}

function showHide(button)
{
	var x = document.getElementById(button.id+"text")
	if (button.textContent == "show")
	{
		x.style.display = "block"
		button.textContent = "hide"
	}
	else
	{
		x.style.display = "none"
		button.textContent = "show"
	}
}

var expr2Grammar = iparse.parseGrammar(
	"root : expr."+
	"expr : expr \"+\" term [add] | expr \"-\" term [sub] | term."+
	"term :	term \"*\" factor [times]| term \"/\" factor [div] | factor."+
	"factor : int | \"(\" expr \")\" | \"-\" factor [min].")

function parseSyntaxTree()
{
	var ast = iparse.parse(document.SyntaxTree.input.value, expr2Grammar)
	if (ast == false)
		d3Tree({ name:"???" })
	else
		d3Tree( ast.transf())
}


//--></script>
<title>MCH2022: A practical approach to parsing</title>
</head><body>

<h1>Workshop: A practical approach to parsing</h1>

This is a page for a workshop at <a href="https://mch2022.org/">MCH2022</A>
about parsing. It serves as both an interactive page to be used during the
workshop and as an introduction to parsing. Use the show buttons to reveal
the explainatory texts.

<h2>What is 3 + 4?</h2>

<style>
div.hidden { display: none; }
</style>

<form name="SimpleExpr">
<textarea name="input" rows="2" cols="80" onkeyup="parseSimpleExpr()">3 + 4 </textarea>
<textarea name="output" rows="1" cols="20"></textarea>
</form>
(type '=' in the input field above to see the answer.)
<p>
<div id="button1text" class="hidden">
Most of use when we read the text '3&nbsp;+&nbsp;4' will immediately think
about seven as the answer. To arrive at this answer, we have read the symbol
'3' and realized that it stands for the number three. Likewise we read four
for the symbol '4'. We also have been taught that the symbol '+' stands for
adding and in our head we add the number three and four to arrive at seven.
<p>
There are some more implicite rules that we employ. We do read the text
'3&nbsp;3' as twice the nunber three, were we read '33' as thirty three. So a
space does matter when placed between digits, whereas we read '3+4' the same as
'3&nbsp;+&nbsp;4'.
</div> <button id="button1" onclick="showHide(this)">show</button>

<h2>What is 3 + 2 * 2 - 1? 9 or 6?</h2>

<div id="button2text" class="hidden">
If you enter 3 + 2 * 2 - 1 in a pocket calculator the answer will probably be
9, because adding three and two gives five. If you next multiply this with two
you get ten. If you subtract one from ten you arrive at nine.
<p>
However, if you take the rule that multiplication (and division) goes before
adding and substracting, you will start with multiplying two with two and if
you substract one from three added with four, you arrive at six.
<p>
In the first case you assume that all operators have the same priority in the
second you assume that some operations have a higher priority than others.
<p>
You can force one of the two interpretations by using round brackets:
<ul>
<li>(3 + 2) * 2 - 1 will return nine
<li>3 + (2 * 2) - 1 will return six
</ul>
Try enter these expression in the input field of the previous paragraph to see
which operator priorities are implemented in this expression evaluator.
</div> <button id="button2" onclick="showHide(this)">show</button>

<h2>What is 12 / 2/2? 12 or 3?</h2>

<div id="button3text" class="hidden">
2/2 is one and twelve divided by one is twelve. But 12 divided by 2 is six and
six divided again by 2 is three. Assuming that spaces have no semantic meaning,
than the question here is, whether the divide operator is left or right
associative. Depending on this, the brackets are thought to be placed as:
<ul>
<li>Left associative: (12 / 2) / 2
<li>right associative: 12 (2 / 2)
</ul>
Note that for 3&nbsp;*&nbsp;2&nbsp;*&nbsp;5 it does not matter whether we place the brackets
like (3&nbsp;*&nbsp;2)&nbsp;*&nbsp;5 or 3&nbsp;*&nbsp;(2&nbsp;*&nbsp;5).

</div> <button id="button3" onclick="showHide(this)">show</button>

<h2>Abstract syntax tree</h2>

<div id="button4text" class="hidden">
An alternative way to represent expressions without using brackets is to use
a tree. (By custom these trees are drawn up-side down.) Below such a tree is
shown for the given expression. Experiment with changing the expression. If
the expression is not correct, three question marks are displayed.
<p>
Such a tree is also called an abstract syntax tree, because it abstracts from
the concrete syntax using characters. From the syntax tree, one cannot see if
brackets were used in the input or not in case they do not make any difference
in how the expression should be calculated. To calculate the value of the
syntax tree below, find a node that only has numbers below them and replace
that node by the result of applying the operation to the numbers. Repeat this
until there is no such node any more.
</div> <button id="button4" onclick="showHide(this)">show</button>
<p>
<center>
<form name="SyntaxTree">
<textarea name="input" rows="2" cols="80" onkeyup="parseSyntaxTree()">3 + 4</textarea>
</form>

<div id="tree-container" style="width: 80%; height: 500px"></div>
</center>

<script><!--
parseSyntaxTree()
//--></script>

<pre>




</pre>
<!--
<div id="button2text" class="hidden">
</div> <button id="button2" onclick="showHide(this)">show</button>
-->
<hr>

<h2>Acknowledgements</h2>

The code for showing the syntax tree is based on <A HREF="http://christos-c.com/treeviewer/"
>Syntactic Tree Viewer</A> by <A HREF="http://christos-c.com/">Christos
Christodoulopoulos</A>, which makes use of <A HREF="https://d3js.org/"
>d3.js</A> and itself is inspired by <A HREF="https://gist.github.com/robschmuecker/7880033"
>D3.js Drag and Drop Zoomable Tree</A> by <A HREF="https://gist.github.com/robschmuecker"
>Rob Schmuecker</A>.

<h2>Work in progress</h2>

This is still work in progress. It will be an improved version of the workshop
<a href="https://fransfaase.github.io/ParserWorkshop/Online_inter_parser.html"
>A modern approach to parsing</A> that I gave on March 20, 2021.


<p>
Author: <a href="https://www.iwriteiam.nl/Frans.html">Frans</a><br>
<a href="https://www.iwriteiam.nl/">Personal website</a><br>
<a href="https://www.iwriteiam.nl/index.html#email">email address</a>
</body></html>
